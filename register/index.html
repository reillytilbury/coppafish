
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../stitch/">
      
      
        <link rel="next" href="../call_spots/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Registration - Coppafish Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#registration" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Coppafish Documentation" class="md-header__button md-logo" aria-label="Coppafish Documentation" data-md-component="logo">
      
  <img src="../images/logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Coppafish Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Registration
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/reillytilbury/coppafish" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
    
  
  Getting started

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../basic_usage/" class="md-tabs__link">
          
  
  Usage

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../overview/" class="md-tabs__link">
        
  
    
  
  Overview

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../stitch/" class="md-tabs__link">
          
  
  Method

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../troubleshoot/" class="md-tabs__link">
        
  
    
  
  Troubleshoot

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../glossary/" class="md-tabs__link">
        
  
    
  
  Glossary

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../contributing/" class="md-tabs__link">
        
  
    
  
  Contributing

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Coppafish Documentation" class="md-nav__button md-logo" aria-label="Coppafish Documentation" data-md-component="logo">
      
  <img src="../images/logo.svg" alt="logo">

    </a>
    Coppafish Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/reillytilbury/coppafish" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting started
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Usage
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic_usage/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Basic Usage
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../advanced_usage/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Advanced Usage
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Method
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Method
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../stitch/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Stitch
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Registration
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Registration
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#high-level-overview" class="md-nav__link">
    <span class="md-ellipsis">
      High Level Overview
    </span>
  </a>
  
    <nav class="md-nav" aria-label="High Level Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-choosing-the-function-space" class="md-nav__link">
    <span class="md-ellipsis">
      1. Choosing the Function Space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-computing-the-transforms" class="md-nav__link">
    <span class="md-ellipsis">
      2. Computing the Transforms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optical-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Optical Flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Optical Flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-how-does-it-work" class="md-nav__link">
    <span class="md-ellipsis">
      1. How does it work?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-practical-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      2. Practical Considerations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Practical Considerations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#speed" class="md-nav__link">
    <span class="md-ellipsis">
      Speed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Interpolation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Interpolation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hard-threshold-interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Hard Threshold Interpolation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extension-to-soft-threshold-interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Extension to Soft Threshold Interpolation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-in-z" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation in z
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterative-closest-point" class="md-nav__link">
    <span class="md-ellipsis">
      Iterative Closest Point
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Iterative Closest Point">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-how-does-it-work_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. How does it work
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      2. Implementation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Implementation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#round-transform" class="md-nav__link">
    <span class="md-ellipsis">
      Round Transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#channel-transform" class="md-nav__link">
    <span class="md-ellipsis">
      Channel Transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      Diagnostics
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Diagnostics">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#different-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Different Methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optical-flow-diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      Optical Flow Diagnostics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#icp-diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      ICP Diagnostics
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ICP Diagnostics">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#summary-statistics" class="md-nav__link">
    <span class="md-ellipsis">
      Summary Statistics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#point-clouds" class="md-nav__link">
    <span class="md-ellipsis">
      Point Clouds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../call_spots/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Call Spots
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../omp/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OMP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../troubleshoot/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Troubleshoot
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Glossary
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#high-level-overview" class="md-nav__link">
    <span class="md-ellipsis">
      High Level Overview
    </span>
  </a>
  
    <nav class="md-nav" aria-label="High Level Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-choosing-the-function-space" class="md-nav__link">
    <span class="md-ellipsis">
      1. Choosing the Function Space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-computing-the-transforms" class="md-nav__link">
    <span class="md-ellipsis">
      2. Computing the Transforms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optical-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Optical Flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Optical Flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-how-does-it-work" class="md-nav__link">
    <span class="md-ellipsis">
      1. How does it work?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-practical-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      2. Practical Considerations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Practical Considerations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#speed" class="md-nav__link">
    <span class="md-ellipsis">
      Speed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Interpolation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Interpolation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hard-threshold-interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Hard Threshold Interpolation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extension-to-soft-threshold-interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      Extension to Soft Threshold Interpolation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-in-z" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation in z
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterative-closest-point" class="md-nav__link">
    <span class="md-ellipsis">
      Iterative Closest Point
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Iterative Closest Point">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-how-does-it-work_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. How does it work
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      2. Implementation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Implementation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#round-transform" class="md-nav__link">
    <span class="md-ellipsis">
      Round Transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#channel-transform" class="md-nav__link">
    <span class="md-ellipsis">
      Channel Transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      Diagnostics
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Diagnostics">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#different-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Different Methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optical-flow-diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      Optical Flow Diagnostics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#icp-diagnostics" class="md-nav__link">
    <span class="md-ellipsis">
      ICP Diagnostics
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ICP Diagnostics">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#summary-statistics" class="md-nav__link">
    <span class="md-ellipsis">
      Summary Statistics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#point-clouds" class="md-nav__link">
    <span class="md-ellipsis">
      Point Clouds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="registration">Registration</h1>
<p>The register section is the part of the pipeline concerned with aligning different rounds and channels. This is crucial for decoding spot colours into genes in the Call Spots and OMP sections. The aim of this section is to find a function <span class="arithmatex">\(g_{trc}(\mathbf{x})\)</span> for each tile, round and channel that takes in a location <span class="arithmatex">\(\mathbf{x}\)</span> on the anchor image for tile <span class="arithmatex">\(t\)</span> and returns the corresponding location in round <span class="arithmatex">\(r\)</span>, channel <span class="arithmatex">\(c\)</span> of the same tile. Since registration is done independently for each tile and we are often only working on one tile, we sometimes omit the subscript <span class="arithmatex">\(t\)</span> in this documentation.</p>
<p>Once we have these transformations <span class="arithmatex">\(g\)</span>, we can get a <span class="arithmatex">\(n_{\textrm{rounds}} \times n_{\textrm{channels}}\)</span> spot colours matrix <span class="arithmatex">\(\boldsymbol{F}(\mathbf{x})\)</span> for each location <span class="arithmatex">\(\mathbf{x}\)</span> in the anchor image of a given tile via</p>
<div class="arithmatex">\[
\boldsymbol{F}(\mathbf{x}) =
\begin{pmatrix}
f_{0, 0}(g_{0, 0}(\mathbf{x})) &amp; \cdots &amp; f_{0, n_c}(g_{0, n_c}(\mathbf{x})) \\
\vdots &amp; \ddots &amp; \vdots \\
f_{n_r, 0}(g_{n_r, 0}(\mathbf{x})) &amp; \cdots &amp; f_{n_r, n_c}(g_{n_r, n_c}(\mathbf{x})) \\
\end{pmatrix},
\]</div>
<p>where <span class="arithmatex">\(f_{rc}(\mathbf{x})\)</span> is the intensity of round <span class="arithmatex">\(r\)</span>, channel <span class="arithmatex">\(c\)</span> at location <span class="arithmatex">\(\mathbf{x}\)</span> in round <span class="arithmatex">\(r\)</span>, channel <span class="arithmatex">\(c\)</span> coordinates. Note that even a single poorly aligned round or channel makes this matrix difficult to decode, which highlights the importance of this section.</p>
<h2 id="high-level-overview">High Level Overview</h2>
<p>We need to consider a few questions when building the register pipeline. Some of the most important are:</p>
<ol>
<li>
<p>How large should our search space of functions for <span class="arithmatex">\(g\)</span> be? Are these functions independent between rounds and channels?</p>
</li>
<li>
<p>How will we actually search this space?</p>
</li>
</ol>
<h3 id="1-choosing-the-function-space">1. Choosing the Function Space</h3>
<p>To choose the set of functions we will use to fit to our data, we need to look for all sources of misalignment. Channel misalgnments are caused by:</p>
<ul>
<li>
<p>The multiple camera setup, meaning channels belonging to different cameras are often slightly shifted or rotated with respect to one another.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Chromatic_aberration">Chromatic aberration</a>, the variable frequency-dependent dispersal of light through the lens. This expands the images from different channels by different amounts. See the figure below.</p>
</li>
</ul>
<p>So the channel-to-channel differences are composed of shifts, rotations and scalings. We model each channel transform by an <a href="https://en.wikipedia.org/wiki/Affine_transformation">affine transform</a> <span class="arithmatex">\(A_c\)</span>.</p>
<p align="center">
  <img src="https://github.com/user-attachments/assets/7a8e510b-9b81-4c2f-a4e1-fd28e7f34b0d" width="300" />
  <br />
  <span>An example of chromatic aberration.</span>
</p>

<p>For round to round differences, we see much less predictable variability. Misalignments arise due to:</p>
<ul>
<li>
<p>Tissue expansion in <span class="arithmatex">\(z\)</span> throughout the rounds,</p>
</li>
<li>
<p>Global shifts arising from movement of the stage,</p>
</li>
<li>
<p>Variable local shifts due to the microfluidics system,</p>
</li>
<li>
<p>Variable local shifts due to gravity or tissue deformation. These shifts have the potential to affect regions very differently. For example, the <a href="https://en.wikipedia.org/wiki/Pyramidal_cell">pyramidal layer</a> is very densely packed and seems to sink more than surrounding areas, leading to different z-shifts in its vicinity. We have also observed rips within tissue samples, which cause different sides of the tissue to move in apart from each other in opposite directions.</p>
</li>
</ul>
<p>The conclusion is that affine transformations <strong>do not</strong> sufficiently capture the richness of round-to-round transformations. We therefore allow for completely arbitrary transformations <span class="arithmatex">\(\mathcal{F}_r\)</span> for each round <span class="arithmatex">\(r\)</span>.</p>
<details class="example">
<summary>Affine Transform Failure Example</summary>
<p>The figure below shows a rip in the tissue and the resulting misalignment in the DAPI channel. This is just one example of a misalignment that cannot be captured by an affine transform.
<p align="center">
  <img src="https://github.com/user-attachments/assets/92066d55-eeca-4783-ab34-2f853c3aedae" width="600" />
  <br />
  <span>A rip in the tissue and two attempts at affine registration. </span>
</p></p>
</details>
<p>To answer the second part of question 1 - empirically, it seems we don't need to find <span class="arithmatex">\(n_{\textrm{rounds}} \times n_{\textrm{channels}}\)</span> independent transforms per tile, we only need <span class="arithmatex">\(n_{\textrm{rounds}} + n_{\textrm{channels}}\)</span>. Explicitly, we model every transform as </p>
<div class="arithmatex">\[
 g_{rc}(\mathbf{x}) = A_{c}(\mathcal{F}_{r}(\mathbf{x})).
\]</div>
<h3 id="2-computing-the-transforms">2. Computing the Transforms</h3>
<p>The round transforms are computed with <a href="https://en.wikipedia.org/wiki/Optical_flow">Optical Flow</a>, while the channel transforms are computed with <a href="https://en.wikipedia.org/wiki/Iterative_closest_point">Iterative Closest Point</a>. For further details see the sections below.</p>
<details class="note">
<summary>Note on Affine Transforms</summary>
<p>When we compute the round transforms <span class="arithmatex">\(\mathcal{F}_r\)</span> these often include some systematic error, like a small shift of 1 pixel and slight underestimation of the z-expansion. This is due to </p>
<ul>
<li>
<p>downsampling of the images used to compute the optical flow transforms,</p>
</li>
<li>
<p>A failure to find good shifts at z-boundaries, due to poor quality images in these planes.</p>
</li>
</ul>
<p>To get around this, we find an affine correction <span class="arithmatex">\(B_r\)</span> for each round. This means our functions <span class="arithmatex">\(g_{rc}\)</span> can be written as </p>
<div class="arithmatex">\[
g_{rc}(\mathbf{x}) = A_{c}(B_{r}(\mathcal{F}_{r}(\mathbf{x})).
\]</div>
<p>We combine the two affine transforms <span class="arithmatex">\(A_c\)</span> and <span class="arithmatex">\(B_r\)</span> to give us the simple formula </p>
<div class="arithmatex">\[
g_{rc}(\mathbf{x}) = A_{rc}(\mathcal{F}_{r}(\mathbf{x})),
\]</div>
<p>which means that in practice our affine maps actually depend on round as well as channel.</p>
</details>
<h2 id="optical-flow">Optical Flow</h2>
<p>We use optical flow to align the anchor DAPI <span class="arithmatex">\(D_{r_{\textrm{ref}}}(\mathbf{x})\)</span>  to the round <span class="arithmatex">\(r\)</span> DAPI <span class="arithmatex">\(D_r(\mathbf{x})\)</span>. The output of this algorithm is a function <span class="arithmatex">\(\mathcal{F}_r\)</span> which satisfies the relation </p>
<div class="arithmatex">\[
D_{r_{\textrm{ref}}}(\mathcal{F}_r(\mathbf{x})) = D_r(\mathbf{x}).
\]</div>
<h3 id="1-how-does-it-work">1. How does it work?</h3>
<p>Suppose we have 2 images <span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span> which we'd like to register. This means for each position <span class="arithmatex">\(\mathbf{x}\)</span> in image <span class="arithmatex">\(J\)</span> we would like to find the shift <span class="arithmatex">\(\mathbf{s}\)</span> satisfying </p>
<div class="arithmatex">\[
I(\mathbf{x} + \mathbf{s}) = J(\mathbf{x}).
\]</div>
<p>Assuming that this <span class="arithmatex">\(\mathbf{s}\)</span> is small and that the function <span class="arithmatex">\(I\)</span> is sufficiently smooth, we can approximate it by a linear function in this neighbourhood. Taylor expanding and rearranging yields:</p>
<div class="arithmatex">\[
\mathbf{s} \cdot \boldsymbol{\nabla} I(\mathbf{x}) \approx J(\mathbf{x}) -  I(\mathbf{x}),
\]</div>
<p>which is called the flow equation, an under-determined equation due to the fact that there are 3 unknowns - each component of <span class="arithmatex">\(\mathbf{s}\)</span>. </p>
<p>There are many different methods that exist to tackle this. The one we use is called the <a href="https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method">Lucas-Kanade</a> method, which assumes that all pixels in a small window of radius <span class="arithmatex">\(r\)</span> (the <code>window_radius</code> parameter with default value 8) around the point <span class="arithmatex">\(\mathbf{x}\)</span> have the same shift <span class="arithmatex">\(\mathbf{s}\)</span>. </p>
<p>Since this method assumes that all pixels have the same shift within this window, the condition that <span class="arithmatex">\(I\)</span> is smooth is very important, as we need to ensure that the same flow equation holds for all <span class="arithmatex">\(x\)</span> in the window. For this to be true, the Hessian <span class="arithmatex">\(\frac{\partial ^2 I}{\partial \mathbf{x}^2}\)</span> cannot be too large in this window.</p>
<p>Lucas-Kanade works as follows. Let <span class="arithmatex">\(\mathbf{x}_1, \cdots, \mathbf{x}_n\)</span> be all the points in this window. Then assuming these all have the same shift <span class="arithmatex">\(\mathbf{s}\)</span>, we can gather the <span class="arithmatex">\(n\)</span> flow equations</p>
<div class="arithmatex">\[
\begin{pmatrix} \boldsymbol{\nabla} I(\mathbf{x}_1)^T \\ \vdots \\ \boldsymbol{\nabla} I(\mathbf{x}_n)^T  \end{pmatrix} \mathbf{s} = \begin{pmatrix} J(\mathbf{x}_1) - I(\mathbf{x}_1) \\ \vdots \\ J(\mathbf{x}_n) - I(\mathbf{x}_n)  \end{pmatrix}, 
\]</div>
<p>which is now overdetermined! This is a better problem to have though, as the solution can be approximated by least squares.</p>
<p>The above derivation makes the following assumptions</p>
<ol>
<li>
<p>The shift <span class="arithmatex">\(\mathbf{s}\)</span> is small,</p>
</li>
<li>
<p>The images are smooth. Ie, the Hessian <span class="arithmatex">\(\frac{\partial ^2 I}{\partial \mathbf{x}^2}\)</span> is not too large,</p>
</li>
<li>
<p>The images <span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span> have the same intensities, so that <span class="arithmatex">\(I(\mathbf{x} + \mathbf{s}) = J(\mathbf{x})\)</span>.</p>
</li>
</ol>
<p>To make sure we meet the assumptions we carry out the following steps:</p>
<ol>
<li>
<p>Shift size:</p>
<ul>
<li>
<p>We apply an initial <a href="https://en.wikipedia.org/wiki/Phase_correlation">Phase Correlation</a> to find any global shift <span class="arithmatex">\(\mathbf{\tilde{s}}\)</span> between <span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span>, and shift <span class="arithmatex">\(I\)</span> by this amount: <span class="arithmatex">\(I(\mathbf{x}) \mapsto I(\mathbf{x} - \mathbf{\tilde{s}})\)</span>. Only once this is done do we carry out optical flow. This way, optical flow only captures the deviations from the global shift <span class="arithmatex">\(\mathbf{\tilde{s}}\)</span>.</p>
</li>
<li>
<p>We downsample the images <span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span> in <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span> before registration, which reduces the relative size of the shift.</p>
</li>
<li>
<p>The <a href="https://scikit-image.org/docs/stable/api/skimage.registration.html#skimage.registration.optical_flow_ilk">implementation</a> we use takes an iterative approach, meaning that after the initial flow field is found the algorithm runs again until some stopping criterion is met.</p>
</li>
</ul>
</li>
<li>
<p>Smoothness:</p>
<ul>
<li>For practical reasons (speed and shift size), we need to downsample the images by a factor in <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span> before registering. We perform the downsampling by taking the mean within each 4 by 4 sub-block as opposed to just extracting every 4th pixel in <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span>. This increases smoothness, as shown below.</li>
<li>We smooth the images with a small Gaussian blur before registering. This needs to be done carefully because too much blurring decreases the resolution of the images and therefore the quality of the registration.</li>
</ul>
</li>
<li>
<p>To ensure we have similar intensity profiles we match the means of <span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span> in similar spatial locations.</p>
</li>
</ol>
<details class="example">
<summary>Smoothing Example</summary>
<p>The figures below shows the effect of downsampling and blurring on the images. The Hessian determinants are shown on the right of the images.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:3"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><input id="__tabbed_1_3" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">Nearest Neighbour Downsampling</label><label for="__tabbed_1_2">Mean Sub-Block Downsampling</label><label for="__tabbed_1_3">Mean Sub-Block Downsampling + Gaussian</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/aa150fb6-169f-49b4-b51f-d4e541061214" width="600" />
  <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/86f75389-c855-47f8-ae42-529e452ff31c" width="600" />
  <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/714dbe0d-d12d-4ca2-9e0e-b7f3aeda576d" width="600" />
  <br />
 </p></p>
</div>
</div>
</div>
</details>
<h3 id="2-practical-considerations">2. Practical Considerations</h3>
<h4 id="speed">Speed</h4>
<p>Speed is an issue with this algorithm, because it needs to be run independently on so many pixels. We take the following steps to optimise it:</p>
<ol>
<li>
<p>As mentioned above, we downsample the images in <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span>. The amount of donwsampling is controlled by the config parameter <code>sample_factor_yx</code> which has default value 4 in both directions, meaning that the algorithm runs 16 times faster than it would without downsampling.</p>
</li>
<li>
<p>We split the downsampled images into 16 subvolumes (4 in <span class="arithmatex">\(y\)</span> and 4 in <span class="arithmatex">\(x\)</span>), and run optical flow in parallel on all of these independent subvolumes. The number of cores used can be adjusted by changing the <code>flow_cores</code> parameter though if left blank this will be computed automatically.</p>
</li>
</ol>
<h4 id="interpolation">Interpolation</h4>
<p>As mentioned previously, the algorithm assumes that the images have the same intensities. This condition is certainly satisfied near cell nuclei, where similar features exist in both images. Far from nuclei though, where all we have is noise, 
the 2 images have completely independent intensities. The result of this is that our flow fields tend to only give reliable results near nuclei, as shown below.</p>
<p align="center">
  <img src="https://github.com/user-attachments/assets/e2674274-6115-4d93-a06c-0efd1c243727" width="600" />
  <br />
  <span> The shifts found by optical flow are only reliable in a small window around cell nuclei.</span>
</p>

<p>This is problematic, as a lot of our reads are found in between cell nuclei! We need to interpolate the values in these regions. </p>
<h5 id="hard-threshold-interpolation">Hard Threshold Interpolation</h5>
<p>Suppose we have a flow field <span class="arithmatex">\(\mathcal{F}\)</span> that we would like to interpolate. We might go about it in the following way:</p>
<ol>
<li>
<p>Choose some locations <span class="arithmatex">\(\mathbf{x}_1, \cdots, \mathbf{x}_n\)</span> where we know the shifts computed <span class="arithmatex">\(\mathbf{s}_1, \cdots, \mathbf{s}_n\)</span> are reliable,</p>
</li>
<li>
<p>Define the interpolated flow to be of the form </p>
</li>
</ol>
<div class="arithmatex">\[
\mathcal{F}_{\textrm{interp}}(\mathbf{x}) = \sum_i w(\mathbf{x}, \mathbf{x}_i) \mathbf{s}_i ,
\]</div>
<p>where the sum is over all sample points <span class="arithmatex">\(\mathbf{x}_1, \cdots, \mathbf{x}_n\)</span>, and the weights <span class="arithmatex">\(w(\mathbf{x}, \mathbf{x}_i)\)</span> have the following properties:</p>
<ul>
<li>
<p><span class="arithmatex">\(\sum_i w(\mathbf{x}, \mathbf{x}_i) = 1\)</span> for all <span class="arithmatex">\(\mathbf{x},\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(w(\mathbf{x}, \mathbf{x}_i)\)</span> is a decreasing function in <span class="arithmatex">\(||\mathbf{x}||\)</span> and <span class="arithmatex">\(w(\mathbf{x}_i, \mathbf{x}_i) \approx 1.\)</span></p>
</li>
</ul>
<p>If these 2 properties are met then <span class="arithmatex">\(\mathcal{F}_{\textrm{interp}}\)</span> will be a weighted average of all the shifts <span class="arithmatex">\(\mathbf{s}_i\)</span>, and since the weights are decreasing, the value of the <span class="arithmatex">\(\mathcal{F}_{\textrm{interp}}\)</span> at each interpolation point <span class="arithmatex">\(\mathbf{x}_i\)</span> will be strongly weighted toward <span class="arithmatex">\(\mathbf{s}_i\)</span>.</p>
<p>Do such weight functions exist? Can we construct them? Yes and yes! Define the function </p>
<div class="arithmatex">\[
K(\mathbf{x}, \mathbf{y}) = \exp \Bigg( -\frac{1}{2 \sigma^2} ||\mathbf{x} - \mathbf{y}||^2 \Bigg),
\]</div>
<p>then we can define the weights by</p>
<div class="arithmatex">\[ 
w(\mathbf{x}, \mathbf{x}_i) = \dfrac{K(\mathbf{x}, \mathbf{x}_i)}{\sum_j K(\mathbf{x}, \mathbf{x}_j)}.
\]</div>
<p>It is easy to see that this satisfies both the desired properties for the weights.</p>
<details class="tip">
<summary>How to choose <span class="arithmatex">\(\sigma\)</span>?</summary>
<p>In the limits: </p>
<ul>
<li>
<p>as <span class="arithmatex">\(\sigma \to 0\)</span> this tends to nearest neighbour interpolation, </p>
</li>
<li>
<p>as <span class="arithmatex">\(\sigma \to \infty\)</span> the image takes the same value everywhere, the mean of the flow image at the sample points.</p>
</li>
</ul>
<p>Another way of saying this is that as <span class="arithmatex">\(\sigma\)</span> grows, so does the radius of contributing pixels.</p>
<p>We expect the shifts to vary more quickly in <span class="arithmatex">\(z\)</span> than in <span class="arithmatex">\(xy\)</span>, so we have a different parameter for the blurring in each direction: <code>smooth_sigma</code>. This takes default values <code>[10, 10, 5]</code> (<span class="arithmatex">\(y\)</span>, <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(z\)</span>).</p>
</details>
<h5 id="extension-to-soft-threshold-interpolation">Extension to Soft Threshold Interpolation</h5>
<p>The above method works well, but having a hard threshold means that some points <span class="arithmatex">\(\mathbf{x}_1, \cdots, \mathbf{x}_n\)</span> are used while others are completely ignored. This can lead to undersampling. A better approach is to employ a soft threshold, where we use all points <span class="arithmatex">\(\mathbf{x}_i\)</span> in the flow image but weight their contributions by the quality of the match at <span class="arithmatex">\(\mathbf{x}_i\)</span>, which we will call <span class="arithmatex">\(\lambda(\mathbf{x}_i)\)</span>.</p>
<p>This results in an interpolation of the form</p>
<div class="arithmatex">\[
\mathcal{F}_{\textrm{interp}}(\mathbf{x}) = \sum_i \lambda(\mathbf{x}_i) w(\mathbf{x}, \mathbf{x}_i) \mathbf{s}_i ,
\]</div>
<p>where the sum now ranges over all points in the image, and the weight functions are given by</p>
<div class="arithmatex">\[ 
w(\mathbf{x}, \mathbf{x}_i) = \dfrac{K(\mathbf{x}, \mathbf{x}_i)}{\sum_j \lambda(\mathbf{x}_j) K(\mathbf{x}, \mathbf{x}_j)}.
\]</div>
<details class="note">
<summary>Definition of the Score <span class="arithmatex">\(\lambda\)</span></summary>
<p>Define the auxilliary score </p>
<div class="arithmatex">\[ 
\eta(\mathbf{x}) = D_{r_{\textrm{ref}}}(\mathcal{F}_r(\mathbf{x}))D_r(\mathbf{x}).
\]</div>
<p>Then our score <span class="arithmatex">\(\lambda\)</span> is defined as</p>
<div class="arithmatex">\[
\lambda(\mathbf{x}) = C_{0,1}\bigg( \dfrac{\eta(\mathbf{x}) - \eta_0}{\eta_1 - \eta_0} \bigg),
\]</div>
<p>where <span class="arithmatex">\(\eta_0\)</span> and <span class="arithmatex">\(\eta_1\)</span> are the 25th and 99th percentiles of <span class="arithmatex">\(\eta\)</span> respectively and <span class="arithmatex">\(C_{a, b}\)</span> is the <a href="https://en.wikipedia.org/wiki/Clamping_(graphics)">clamp function</a>.</p>
<p>This results in a score of 0 for common low intensity background regions, and 1 for high quality regions like cell nuclei.</p>
</details>
<h4 id="extrapolation-in-z">Extrapolation in z</h4>
<p>The quality of the z-shifts drops rapidly towards the top end of the z-stack, because the optical flow uses windows of fixed radius (the <code>window_radius</code> parameter, which has default value 8). When these windows go over the edge of the image, the shifts get biased towards 0. This problem is made worse when the initial shift found is large in <span class="arithmatex">\(z\)</span>, as then the adjusted image is padded with many zeros.</p>
<p>We get around this problem by linearly predicting the z-shifts from the bottom and middle of the image and replacing all z-shifts with these linear estimates. This is illustratedc in the figure below.</p>
<p align="center">
<img src="https://github.com/user-attachments/assets/54d294f1-241c-4ea0-9f66-f700544fbd38" width="600" />
<br />
<span>Interpolation of x-y shifts, and extrapolation of z-shifts. </span>
</p>

<h2 id="iterative-closest-point">Iterative Closest Point</h2>
<p>We now attempt to find the affine corrections to the flows found earlier. As mentioned previously, this will be an affine transform for each tile <span class="arithmatex">\(t\)</span>, round <span class="arithmatex">\(r\)</span> and channel <span class="arithmatex">\(c\)</span>. Furthermore, it will be separated into 2 transforms:</p>
<ul>
<li>
<p>A round transform <span class="arithmatex">\(B_{r}\)</span> which corrects for any errors in the flow <span class="arithmatex">\(\mathcal{F}_r\)</span>,</p>
</li>
<li>
<p>A channel transform <span class="arithmatex">\(A_{c}\)</span> which corrects for all sources of the channel to channel variability.</p>
</li>
</ul>
<p>We have omitted the tile subscript, but keep in the back of your mind that these transforms vary between tiles.</p>
<h3 id="1-how-does-it-work_1">1. How does it work</h3>
<p>Optical flow took in 2 <strong>images</strong> (<span class="arithmatex">\(I\)</span> and <span class="arithmatex">\(J\)</span> ) as inputs and returned 3 images of the same size as outputs (the flow in each direction <span class="arithmatex">\(y\)</span>, <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(z\)</span>). ICP differs in that it takes in 2 <strong>point-clouds</strong> as input and returns an affine transform <span class="arithmatex">\(A\)</span> as output. </p>
<p>Let <span class="arithmatex">\(X = \begin{pmatrix} \mathbf{x}_1, \cdots,  \mathbf{x}_m \end{pmatrix}\)</span> be the base point cloud and <span class="arithmatex">\(Y = \begin{pmatrix} \mathbf{y}_1, \cdots,  \mathbf{y}_n \end{pmatrix}\)</span>  be the point cloud we are trying to match this to.</p>
<p>In our case <span class="arithmatex">\(X\)</span> is the set of anchor points and <span class="arithmatex">\(Y\)</span> is the set of points in a given round and channel. So for every point <span class="arithmatex">\(\mathbf{y}_i\)</span> in <span class="arithmatex">\(Y\)</span>, we expect there to be a corresponding point <span class="arithmatex">\(\mathbf{x}_{\beta(i)}\)</span> in <span class="arithmatex">\(X\)</span> (the converse is not true). Estimating the matching <span class="arithmatex">\(\beta\)</span> between base and target points is the main difficulty in ICP. Some common methods to estimate this matching include:</p>
<ol>
<li>
<p>We let <span class="arithmatex">\(\mathbf{x}_{\beta(i)}\)</span> be the closest point from <span class="arithmatex">\(X\)</span> to the point <span class="arithmatex">\(\mathbf{y}_i\)</span>,</p>
</li>
<li>
<p>The same as 1. but if there is no point in <span class="arithmatex">\(X\)</span> within a certain radius <span class="arithmatex">\(r\)</span> of <span class="arithmatex">\(\mathbf{y}_i\)</span> we don't bother to find a match,</p>
</li>
<li>
<p>The same as 2. but we allow different radii in <span class="arithmatex">\(y\)</span>, <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(z\)</span>. This is useful if we have some prior that the misalignment affects <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span> more than <span class="arithmatex">\(z\)</span>, as we typically do.</p>
</li>
<li>
<p>The same as 1. but we remove outliers where the shift <span class="arithmatex">\(\mathbf{y}_i -  \mathbf{x}_{\beta(i)}\)</span> seems to be very different from others in its vicinity.</p>
</li>
</ol>
<p>We use approach 3. The parameters config parameters <code>neighb_dist_thresh_yx</code> and <code>neighb_dist_thresh_z</code> refer to <span class="arithmatex">\(r_{yx}\)</span> and <span class="arithmatex">\(r_z\)</span> respectively. </p>
<details class="warning">
<summary>Setting <span class="arithmatex">\(r_z\)</span> too low</summary>
<p>Currently we think that ICP is correcting <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(x\)</span> more than <span class="arithmatex">\(z\)</span>, so we have <span class="arithmatex">\(r_{z} &lt; r_{xy}\)</span>. If this changes in the future (for example, if optical flow is not sufficiently capturing the variable z-shifts) then increasing <span class="arithmatex">\(r_z\)</span> will allow ICP to have greater impact on the <span class="arithmatex">\(z\)</span> transforms.</p>
</details>
<p>Once we have a matching <span class="arithmatex">\(\beta\)</span>, ICP works by finding an affine map <span class="arithmatex">\(A\)</span> minimising the loss function </p>
<div class="arithmatex">\[
L(A) = \sum_{i} || A \mathbf{x}_{\beta(i)} - \mathbf{y}_i ||^2,
\]</div>
<p>(where the sum is over all those elements in <span class="arithmatex">\(Y\)</span> that have been assigned a match) and then iterate this process of matching then minimising until some stopping criteria are met. We have the 2 following stopping criteria:</p>
<ol>
<li>
<p>If 2 consecutive matchings are identical <span class="arithmatex">\(\beta_{t+1} = \beta_t\)</span> then ICP gets stuck in an infinite loop, so we stop the iterations.</p>
</li>
<li>
<p>The maximum number of iterations are reached. This is set by <code>icp_max_iter</code> which has default value 50.</p>
</li>
</ol>
<p>The algorithm can be summarised as follows:
<div class="highlight"><pre><span></span><code># Args:
# X = m x 4 matrix (base positions padded)
# Y = n x 3 matrix (target positions)
# transform_initial = 4 x 3 initial transform
# epsilon = distance threshold

# Initialize
transform = transform_initial
X = X @ transform
neighb_prev = None

# begin loop
for _ in range(n_iter):
    # Find closest point in X to each point in Y
    neighb = [argmin_k || X[k] - Y[j] || for j in range(n)]

    # Remove these matches if they are above the neighb_dist_thresh
    neighb = [neighb [j] if || X[neighb[j]] - Y[j] || &lt; epsilon, 
              else None for j in range(n)]

    # Terminate if no change in neighbours
    if neighb == neighb_prev:
        QUIT

    # Update transform
    transform_update = argmin_B sum_j || X[neighb[j]] @ B - Y[j] || ** 2
    X = X @ transform_update
    transform = transform_update @ transform

    # Update neighb_prev
    neighb_prev = neighb
</code></pre></div></p>
<h3 id="2-implementation">2. Implementation</h3>
<p>Let <span class="arithmatex">\(X_{r, c}\)</span> be the <span class="arithmatex">\(n_{\textrm{spots}}(r,c) \times 3\)</span> matrix of all the spots found on round <span class="arithmatex">\(r\)</span> channel <span class="arithmatex">\(c\)</span>.</p>
<details class="note">
<summary>Min Spots Criterion</summary>
<p>ICP will not run on a tile, round, channel with too few spots. This threshold is set by <code>icp_min_spots</code> which has default value 100.</p>
</details>
<h4 id="round-transform">Round Transform</h4>
<p>To compute the round transforms <span class="arithmatex">\(B_r\)</span>, we first adjust <span class="arithmatex">\(X_{r_{\textrm{ref}}, c_{\textrm{ref}}}\)</span> by the flow to yield <span class="arithmatex">\(\mathcal{F}_r(X_{r_{\textrm{ref}}, c_{\textrm{ref}}})\)</span>, which should approximately put the anchor spots in round <span class="arithmatex">\(r\)</span> coordinates. We align these to the target points <span class="arithmatex">\(X_{r, c_{\textrm{ref}}}\)</span>. As a formula this reads as</p>
<div class="arithmatex">\[
B_r = \textrm{ICP} (\textrm{base} = \mathcal{F}_r(X_{r_{\textrm{ref}}, c_{\textrm{ref}}}), \quad \textrm{target} = X_{r, c_{\textrm{ref}}}).
\]</div>
<p>This should capture any systematic affine errors in the flow field <span class="arithmatex">\(\mathcal{F}_r\)</span>.</p>
<h4 id="channel-transform">Channel Transform</h4>
<p>To compute the channel transforms <span class="arithmatex">\(A_c\)</span> we align the anchor points <span class="arithmatex">\(X_{r_{\textrm{ref}}, c_{\textrm{ref}}}\)</span> with all points in channel <span class="arithmatex">\(c\)</span>, regardless of round. We adjust these points to be in the anchor coordinate system. In a formula, this reads as</p>
<div class="arithmatex">\[
A_c = \textrm{ICP} (\textrm{base} = X_{r_{\textrm{ref}}, c_{\textrm{ref}}}, \quad  \textrm{target} = \bigcup _r B_r ^{-1} (\mathcal{F}_r ^{-1} (X_{r, c}))).
\]</div>
<p>The inverse transforms are used above because we are going from round <span class="arithmatex">\(r\)</span> coordinates to round <span class="arithmatex">\(r_{\textrm{ref}}\)</span> coordinates, which is opposite to the way we computed the transforms.</p>
<p>The chain of transforms is captured in the figure below:</p>
<p align="center">
  <img src="https://github.com/user-attachments/assets/9362be6e-4b67-419b-a76e-661f98d84fef" width="450" />
  <br />
  <span> Chain of transformations learnt for each round and channel.</span>
</p>

<h2 id="diagnostics">Diagnostics</h2>
<p>Problems in registration can ruin several downstream analyses. These problems can be  diagnosed by looking at the Registration Viewer, as follows:</p>
<div class="highlight"><pre><span></span><code>from coppafish import Notebook, RegistrationViewer
nb_file = &quot;path/to/notebook&quot;
nb = Notebook(nb_file)
rv = RegistrationViewer(nb)
</code></pre></div>
<p>This will open a viewer with the following home screen:</p>
<p align="center">
  <img src="https://github.com/user-attachments/assets/18f4c16a-9005-4808-acaa-e71fbeac3670" width="600" />
    <br />
    <span> The Registration Viewer </span>
</p>

<p>This shows the round registration on the top row and the channel registration on the bottom row. This is displayed as follows:</p>
<ul>
<li>
<p>Each image in the top row shows a small patch of <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{dapi}})\)</span> in red, overlaid with <span class="arithmatex">\((r, c_{\textrm{dapi}})\)</span> in green. </p>
</li>
<li>
<p>Each image in the bottom row shows a small patch of <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{ref}})\)</span> in red, overlaid with <span class="arithmatex">\((r_{\textrm{mid}}, c)\)</span> in green.</p>
</li>
</ul>
<p>Errors in registration may occur because of poor optical flow or ICP. The home screen shows small snippets of the images which indicate the overall quality of the registration. If these all look good, then the registration is likely fine. If not, then the options in the left panel will help diagnose the reason for poor round or channel registration.</p>
<h3 id="different-methods">Different Methods</h3>
<p>There are 2 sliders at the bottom of the viewer. The z-slider allows you to move through the z-planes, while the method slider allows you to choose between different methods of displaying the images. The methods are as follows:</p>
<ol>
<li>
<p><strong>No Registration</strong>: This shows the images without any registration. This is useful to see how big the misalignments are.</p>
</li>
<li>
<p><strong>Optical Flow</strong>: This shows the images after the optical flow has been applied, but not the ICP transforms <span class="arithmatex">\(A_{trc}\)</span>. The channel transforms shown here use the optical flow plus the initial affine transform <span class="arithmatex">\(\tilde{A}_c\)</span> learnt from the fluorescent bead images.</p>
</li>
<li>
<p><strong>Optical Flow + ICP</strong>: This shows the images after the optical flow has been applied, and the ICP transforms <span class="arithmatex">\(A_{trc}\)</span> have been applied. This is the final registration.</p>
</li>
</ol>
<div class="admonition example">
<p class="admonition-title">Registration with Different Methods</p>
<p>The figures below show a good example of the different stages of round registration. The largest changes are made by optical flow, while ICP makes smaller corrections.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:3"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><input id="__tabbed_2_3" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">No Registration</label><label for="__tabbed_2_2">Optical Flow</label><label for="__tabbed_2_3">Optical Flow + ICP</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/6da39f9f-2743-4e19-a075-19268a8c8411" width="600" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/f748d2dd-3ab0-4127-b3dc-3399a2c1a47a" width="600" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/ca9bd825-440f-46fc-9420-7988ed6593de" width="600" />
 <br />
 </p></p>
</div>
</div>
</div>
<p>The figures below show the different stages of channel registration. Here, image 1 is unregistered, image 2 is registered with optical flow and the initial affine transform, and image 3 is registered with optical flow and ICP. Most of the work done here is by ICP as the initial affine transform is not very good.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:3"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><input id="__tabbed_3_3" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">No Registration</label><label for="__tabbed_3_2">Optical Flow + Initial Affine Transform</label><label for="__tabbed_3_3">Optical Flow + ICP</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/b7d7de6c-69df-4c28-beea-e9fd3bda2182" width="600" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/a5698e0b-05f8-4cc7-ae39-5774f75b6d39" width="600" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/18f32ed5-637f-454b-b3aa-5103f7f29c09" width="600" />
 <br />
 </p></p>
</div>
</div>
</div>
</div>
<h3 id="optical-flow-diagnostics">Optical Flow Diagnostics</h3>
<p>The Optical Flow Viewer can be selected on the left hand panel to view the optical flow fields for a particular round. This will open a screen like the one below:</p>
<p align="center">
<img src="https://github.com/user-attachments/assets/a5061aac-611b-4009-a32a-0d7097d3acdd" width="600" />
<br />
<span> The Optical Flow Viewer.</span>
</p>

<p>This shows 3 columns of images:</p>
<ol>
<li>
<p><strong>No Flow</strong>: This shows <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{dapi}})\)</span> in red, overlaid with <span class="arithmatex">\((r, c_{\textrm{dapi}})\)</span> in green before optical flow has been applied.</p>
</li>
<li>
<p><strong>Raw Flow</strong>: This shows <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{dapi}})\)</span> in red, overlaid with <span class="arithmatex">\((r, c_{\textrm{dapi}})\)</span> in green after the raw flow has been applied. </p>
</li>
<li>
<p><strong>Smoothed Flow</strong>: This shows <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{dapi}})\)</span> in red, overlaid with <span class="arithmatex">\((r, c_{\textrm{dapi}})\)</span> in green after the smoothed flow has been applied. </p>
</li>
</ol>
<p>Rows 2, 3 and 4 show the raw and smooth flows in the <span class="arithmatex">\(y\)</span>, <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(z\)</span> directions respectively, while row 5 shows the correlation between the raw flow and the target image (this is the score <span class="arithmatex">\(\lambda(\mathbf{x})\)</span> which is used to compute the smoothed flow).</p>
<div class="admonition example">
<p class="admonition-title">Optical Flow Viewer Example</p>
<p>The figures below show an example of the different stages of optical flow. No flow shows a lot of misalignment. The raw flow shows the initial flow field, which is right in most places but wrong in others (particularly at edges). The smoothed flow is the final flow field, which is much better than the raw flow.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:3"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><input id="__tabbed_4_3" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">No Flow</label><label for="__tabbed_4_2">Raw Flow</label><label for="__tabbed_4_3">Smoothed Flow</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/0f74c38b-3480-4176-97f0-4ee23f735817" width="800" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/8f7db328-14f4-45e2-a485-a210d43749f7" width="800" />
 <br />
 </p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
  <img src="https://github.com/user-attachments/assets/24e2351e-c309-4f18-b19f-618a9be40d05" width="800" />
 <br />
 </p></p>
</div>
</div>
</div>
<p>The figure below is a closer look at the raw and smoothed flow fields, with the correlation plotted below them in blue.</p>
<p><p align="center">
<img src="https://github.com/user-attachments/assets/c89c143b-646a-481f-aa13-188143620bf7" width="600" />
<br />
</p></p>
</div>
<h3 id="icp-diagnostics">ICP Diagnostics</h3>
<p>Several diagnostics are available for ICP, and can be selected from the left hand panel. These viewers either show summary statistics or point clouds used to compute the transforms.</p>
<h4 id="summary-statistics">Summary Statistics</h4>
<p>These show things like the average shift and scale for each round and channel and the convergence rates of each round and channel. This is useful for identifying outliers for some round or channel.</p>
<div class="admonition example">
<p class="admonition-title">Summary Statistics</p>
<p>The figure below shows the shifts and scales of the ICP correction for each round and channel of a particular tile. These numbers alone do not tell us the whole picture about the affine transforms (for example they don't tell us about the rotation), but they can be useful for identifying outliers, and seeing how much work ICP is doing.</p>
<p>In this image, very bright or very dark columns indicate large round corrections, while very bright or very dark rows indicate large channel corrections. Take note of the following points:</p>
<ul>
<li>The round corrections are largest in z. </li>
<li>The channel corrections are largest in x and y.</li>
<li>The channel scales and shifts are very similar in channels separated by a multiple of 4. This is because these channels come from the same camera, and therefore have roughly the same offset.</li>
<li>Even though these scales are very small (around 1.003 at most), the images have size around 2000 pixels. This means that if we didn't correct for these scales, the images would be off by around 6 pixels, which is a lot.</li>
</ul>
<p><p align="center">
<img src="https://github.com/user-attachments/assets/e5447df4-77be-4d59-8bdf-43c21ffb4bf8" width="600" />
<br />
</p></p>
</div>
<h4 id="point-clouds">Point Clouds</h4>
<p>These show the point clouds used to compute the round corrections <span class="arithmatex">\(B_r\)</span> and channel corrections <span class="arithmatex">\(A_c\)</span>. This is much more detailed than the summary statistics and can be used to understand why convergence fails in certain cases.</p>
<div class="admonition example">
<p class="admonition-title">Point Clouds</p>
<p>The figure below shows the point clouds used to compute the channel correction <span class="arithmatex">\(A_c\)</span> for <span class="arithmatex">\(c = 5\)</span>. </p>
<ul>
<li>The white circles are the points from <span class="arithmatex">\((r_{\textrm{ref}}, c_{\textrm{ref}})\)</span>,</li>
<li>the red crosses are the points from <span class="arithmatex">\((r_{\textrm{mid}}, c)\)</span>. </li>
<li>The cyan lines show the matches between points in the unaligned point clouds,</li>
<li>the blue lines show the matches between points in the aligned point clouds. </li>
<li>The yellow background image is bright in places where there are many matches and dark where there are few.</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">No Registration</label><label for="__tabbed_5_2">Channel Correction</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
<img src="https://github.com/user-attachments/assets/151d275b-062b-4bcc-bbc6-26fcb1ab90ff" width="600" />
<br />
</p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
<img src="https://github.com/user-attachments/assets/aaf92759-92bc-416a-a5d5-a6ac14b614aa" width="600" />
<br />
</p></p>
</div>
</div>
</div>
<p>The figure below shows the point clouds used to compute the round correction <span class="arithmatex">\(B_r\)</span> for <span class="arithmatex">\(r = 1\)</span>. This viewer has the same components as the channel correction viewer but it defaults to showing all z-planes, as this is what ICP corrects for the most.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">No Registration</label><label for="__tabbed_6_2">Round Correction</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><p align="center">
<img src="https://github.com/user-attachments/assets/2df9bb7c-8967-4008-9cf9-12e957654752" width="600" />
<br />
</p></p>
</div>
<div class="tabbed-block">
<p><p align="center">
<img src="https://github.com/user-attachments/assets/5cbdbd4d-9373-4fb4-ac34-594203b1512b" width="600" />
<br />
</p></p>
</div>
</div>
</div>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.tabs.sticky", "content.code.annotation", "content.code.copy"], "search": "../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="../javascripts/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="../javascripts/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>