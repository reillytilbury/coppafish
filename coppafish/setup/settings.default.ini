; Default parameters
;
; Do not modify this file!  If you would like to change a value, create a new
; settings.ini file and set only the parameters you would like to be different
; than those found in this file.
;
; For extraction to markdown, we need:
; Require a comment for each section and variable (can be blank though).
; Lines after a header are the comments describing that section.
; Lines before a variable are the comment for that variable.
; Need an empty line between section comment and comment of first variable in that section.
; Separator between variable name and default value is ' = ' i.e. a space on each side.


[file_names]
; The *file_names* section specifies the files that will be used throughout the pipeline.
; Variables in this section can be changed at any point in the pipeline, and the notebook created using it can still
; be loaded in.


; Name of notebook file in output directory will be *notebook_name*
notebook_name = notebook

; Directory where the raw .nd2 files or .npy stacks are
input_dir =

; Directory where notebook is saved
output_dir =

; Directory where tile .npy files saved
tile_dir =

; Names of .nd2 files for the imaging rounds. Leave empty if only using anchor.
;;DELETE
round =

; Name of the file for the anchor round. Leave empty if not using anchor.
;;DELETE
anchor =

; .nd2 or .npy indicating the data type of the raw data.
;DELETE
raw_extension = .nd2

; If .npy raw_extension, this is the name of the .json file in *input_dir* which contains the metadata
; required extracted from the initial .nd2 files.
; I.e. it contains the output of *coppafish/utils/nd2/save_metadata*:
;
; - `xy_pos` - `List [n_tiles x 2]`. xy position of tiles in pixels.
;
; - `pixel_microns` - `float`. xy pixel size in microns.
;
; - `pixel_microns_z` - `float`. z pixel size in microns.
;
; - `sizes` - dict with fov (`t`), channels (`c`), y, x, z-planes (`z`) dimensions.
;DELETE
raw_metadata =

; csv file giving the approximate raw intensity for each dye with each camera/laser combination.
; If not set, the file *coppafish/setup/dye_camera_laser_raw_intensity.csv* file will be used.
dye_camera_laser =

; Text file which contains the codes indicating which dye to expect on each round for each gene.
code_book =

; Text file saved in *tile_dir* containing `extract['scale']` and `extract['scale_anchor']` values used to create
; the tile .npy files in the *tile_dir*. If the second value is 0, it means `extract['scale_anchor']` has not
; been calculated yet.
;
; If the extract step of the pipeline is re-run with `extract['scale']` or `extract['scale_anchor']` different
; to values saved here, an error will be raised.
;DELETE
scale = scale

; compressed numpy file in output directory indicating average spot shape (point spread function) as shape zyx.
; If deconvolution required and file does not exist, the default will be used.
; (this is psf before tapering and scaled to fill uint16 range).
; The psf must be saved at key "arr_0".
psf = 

; csv files in *output_dir* where plotting information for pciSeq will be saved.
; First file is name where *omp* method output will be saved.
; Second file is name where *ref_spots* method output will be saved.
; If files don't exist, they will be created when the function *coppafish/export_to_pciseq* is run.
pciseq = pciseq_omp, pciseq_anchor, pciseq_prob

fluorescent_bead_path =

; location of npy file containing (n_channels x n_dyes) ndarray to use as the initial bleed matrix. If empty, uses
; a hardcoded matrix, located in the ``call_reference_spots.py`` script.
initial_bleed_matrix =


[basic_info]
; The *basic_info* section indicates information required throughout the pipeline.

; Round that is the anchor
anchor_round =

; Channel in anchor round used as reference and to build coordinate system on. Usually channel with most spots.
; Leave blank if anchor not used.
anchor_channel = 27

; Channel in anchor round that contains *DAPI* images. This does not have to be in `use_channels`
; as anchor round is dealt with separately. Leave blank if no *DAPI*.
dapi_channel = 0


; Channels in imaging rounds to use throughout pipeline. Leave blank to use all.
use_channels =

; Imaging rounds to use throughout pipeline. Leave blank to use all.
use_rounds =

;will delete soon
use_anchor = True

; z planes used to make tile .npy files. Leave blank to use all.
; If 2 values provided, all z-planes between and including the values given will be used.
use_z =

; Tiles used throughout pipeline. Leave blank to use all.
; For an experiment where the tiles are arranged in a 4 x 3 (ny x nx) grid, tile indices are indicated as below:
;
; | 2  | 1  | 0  |
;
; | 5  | 4  | 3  |
;
; | 8  | 7  | 6  |
;
; | 11 | 10 | 9  |
use_tiles =

; Dyes to use when when assigning spots to genes. Leave blank to use all.
use_dyes =

; Name of dyes used in correct order. So for gene with code `360...`,
; gene appears with `dye_names[3]` in round 0, `dye_names[6]` in round 1, `dye_names[0]` in round 2 etc.
; If left blank, then assumes each channel corresponds to a different dye i.e. code 0 in code_book = channel 0.
; For quad_cam data, this needs to be specified.
dye_names = ATTO425, AF488, DY520XL, AF532, AF594, AF647, AF750

; This is added onto every tile (except DAPI) when it is saved and
; removed from every tile when loaded. Required so we can have negative pixel values when save to .npy as uint16.
tile_pixel_value_shift = 15000

is_3d = True

; Specific images can be set to empty if they are corrupted. They will be kept as zeroes, causing no affect on the gene
; calling. Each bad image is added following the notation `bad_trc = (t1, r1, c1), (t2, r2, c2), ...`
bad_trc =

channel_camera =

channel_laser =

ref_round =

ref_channel =

; If use_z is not given, the first z index is ignored.
ignore_first_z_plane = True


[notifications]
; The *notifications* sections contains parameters related to notifying the user about the coppafish pipeline.

; The filename where every coppafish message is logged.
log_name = pipeline.log

; see coppafish/log/base.py for different severity levels. A log with severity >= minimum_print_severity will be
; printed to the terminal.
minimum_print_severity = 20

; email for the account that will send the email. Must be an email with Google SMTP enabled.
sender_email = coppafish@gmail.com

sender_email_password = 

; email address to receive a message when coppafish finishes running or crashes.
email_me = 


[extract]
; The *extract* section contains parameters which specify how to save the untiltered, raw microscope images to produce
; the .zarr files saved to `file_names['tile_dir']` in the 'extract' subdirectory.

; The number of 90 degree rotations on the x/y planes applied to each extracted tile individually. A positive number is 
; an anti-clockwise rotation.
num_rotations = 1

; If an extracted image z plane has a mean below z_plane_mean_warning, then a warning is raised.
z_plane_mean_warning = 125


[filter]
; Here we specify filtering parameters used to filter raw, extracted images which are then re-saved as zarr arrays at 
; `file_names['tile_dir']` in the `filter` subdirectory.

; Forces all computations to run on the CPU only.
force_cpu = false

; Filtering for DAPI images is a tophat with r_dapi radius.
; Should be approx radius of object of interest. Typical = 48.
; Leave blank for no DAPI image filtering except Wiener deconvolution.
r_dapi =

; `nb.extract.auto_thresh[t,r,c]` is default threshold to find spots on tile t, round r, channel c.
; Value is set to `auto_thresh_multiplier * median(abs(image))` where
; `image` is the image produced for tile t, round r, channel c in the extract step of the pipeline and saved to
; `file_names['tile_dir']`.
auto_thresh_multiplier = 17

; For 3D pipeline, whether to perform wiener deconvolution.
deconvolve = True

; Constant used to compute wiener filter from the `psf`.
wiener_constant = 50

; When applying the wiener filter, we pad the raw image to median value
; linearly with this many pixels at end of each dimension.
wiener_pad_shape = 20, 20, 3


[find_spots]
; The *find_spots* section contains parameters which specify how to convert the images produced in the extract section
; to point clouds.


; For a pixel to be detected as a spot, two conditions must be met:
; 1) The pixel intensity is above the computed nb.filter.auto_thresh[t, r, c] for the particular tile, round, channel.
; 2) The pixel is the largest intensity in a local ellipsoid region, its size is governed by radius_xy and radius_z.
radius_xy = 5

radius_z = 2

; If number of spots detected on particular z-plane of an imaging round is greater than
; this, then will only select the `max_spots_2d` most intense spots on that z-plane.
; I.e. PCR works better if trying to fit fewer more intense spots.
; This only applies to imaging rounds and not ref_round/ref_channel as need lots of spots then.
; In 2D, allow more spots as only 1 z-plane
max_spots_2d = 500

; Same as `max_spots_2d` for the 3D pipeline. In 3D, need to allow fewer spots on a z-plane as have many z-planes.
max_spots_3d = 500

; To determine if spots are isolated, filter image with annulus between `isolation_radius_inner` and `isolation_radius`.
; `isolation_radius_inner` should be approx the radius where intensity of spot crosses from positive to negative.
; It is in units of xy-pixels.
; This filtering will only be applied to spots detected in the ref_round/ref_channel.
isolation_radius_inner = 4

; From the found spots in the reference round/channel, spots are labelled as isolated if they meet the condition:
; 1) The spot is the only spot in a local ellipsoid region, size governed by isolation_radius_xy and isolation_radius_z.
isolation_radius_xy = 14

isolation_radius_z = 4

; Used in *coppafish/find_spots/base/check_n_spots*
;
; A warning will be raised if for any tile, round, channel the number of spots detected is less than:
;
; `n_spots_warn = n_spots_warn_fraction * max_spots * nb.basic_info.nz`
;
; where `max_spots` is `max_spots_2d` if *2D* and `max_spots_3d` if *3D*.
n_spots_warn_fraction = 0.1

; Used in *coppafish/find_spots/base/check_n_spots*. An error is raised if any of the following are satisfied:
;
; * For any given channel, the number of spots found was less than `n_spots_warn` for at least
; the fraction `n_spots_error_fraction` of tiles/rounds.
;
; * For any given tile, the number of spots found was less than `n_spots_warn` for at least
; the fraction `n_spots_error_fraction` of rounds/channels.
;
; * For any given round, the number of spots found was less than `n_spots_warn` for at least
; the fraction `n_spots_error_fraction` of tiles/channels.
n_spots_error_fraction = 0.5


[stitch]
; The *stitch* section contains parameters which specify how the overlaps between neighbouring tiles are found.


; Expected fractional overlap between tiles.
expected_overlap = 0.1



[register]
; The *register* section contains parameters which specify how the affine transforms from the ref_round/ref_channel
; to each imaging round/channel are found from the shifts found in the *register_initial* section.

; the fluorescent beads are detected using a circular hough transform. This requires an estimate of the bead radii in
; yx pixels. The bead radii should be estimated from the raw images.
bead_radii = 10, 11, 12

; the optical flow algorithm is run on down-sampled images in yx. This parameter specifies the down-sampling factor.
sample_factor_yx = 4

; the number of yx chunks to break the downsampled image into for optical flow.
chunks_yx = 5

; the overlap between chunks as a ratio of the chunk size,
overlap_yx = 0.25

; the optical flow algorithm works by comparing a window of pixels in the reference image to a window of pixels in the
; target image. This parameter specifies the radius of the window.
window_radius = 8

; optical flow is interpolated in between good performing regions. This parameter specifies the size of the smoothing
; kernel used in the interpolation.
smooth_sigma = 10, 10, 5

; Optical flow can work in parallel. This specifies how many CPU cores to use. Default: maximum number of CPU cores.
flow_cores =

; the maximum shift in y, x and z that can be detected by the optical flow algorithm. any larger shifts will be
; detected as the maximum shift.
flow_clip = 40, 40, 15

; Basically the distance in y and x pixels below which neighbours are a good match.
neighb_dist_thresh_yx = 5

; The distance threshold in z pixels below which neighbours are a good match.
; If not given, it is set to `ceil(neighb_dist_thresh_yx * pixel_size_yx / pixel_size_z)`
neighb_dist_thresh_z =

; minimum number of spots required to run icp on a given t, r, c
icp_min_spots = 100

; maximum number of iterations for icp
icp_max_iter = 50


[call_spots]
; The *call_spots* section contains parameters which specify how the spots are assigned to genes and how certain scale
; factors are computed.

; this is the threshold for spots to be used for computing bled codes (tile independent and tile dependent), the
; bleed matrix and thus subsequently the scale factors.
gene_prob_threshold = 0.9

; this is a list of length n_channels_use and specifies the target brightness for each channel in its brightest dye.
; for 7 channels we typically use [1, 1, 0.9, 0.7, 0.8, 1, 1] as the target values.
; for 9 channels we typically use [1, 0.8, 0.2, 0.9, 0.6, 0.8, 0.3, 0.7, 1] as the target values.
; If left blank, pipeline will check n_channels_use and set to the relevant option above.
target_values =

; this is a list of length n_channels_use and specifies the dye we will make brightest for each channel
; for 7 channels we typically use [0, 1, 3, 2, 4, 5, 6] as the target values.
; for 9 channels we typically use 0, 1, 1, 3, 2, 4, 5, 5, 6 as the target values.
; If left blank, pipeline will check n_channels_use and set to the relevant option above.
d_max =

; This is the concentration parameter used in the von Mises-Fisher distribution for the spot colours. A value of 0
; assigns uniform probability to all genes, while a large value assigns a high probability to the most likely gene.
; For 73 genes, we typically use 2. For 300+ genes, we typically use 4.
; If left blank, pipeline will check how may genes are used and set it to log(1 + n_genes // 75) + 2
kappa =

; this is the number of spots necessary to significantly alter the mean vector of spot colours parallel to the
; expected colour
concentration_parameter_parallel = 10

; this is the number of spots necessary to significantly alter the mean vector of spot colours perpendicular to the
; expected colour
concentration_parameter_perpendicular = 50


[omp]
; The *omp* section contains parameters which are use to carry out orthogonal matching pursuit (omp) on every pixel,
; as well as how to convert the results of this to spot locations.

; Normalise colours between rounds, channels and tiles using computed normalisation values in call spots.
colour_normalise = True

; If true, try to subtract the background from OMP colours before running OMP. The background is subtracted by 
; computing a weighted dot product on background genes then subtracting this away from the colour. A background gene 
; is just ones in every channel for a single round. Therefore, the number of unique background genes is the number of 
; sequencing rounds.
fit_background = True

; When OMP finds the next best gene to assign from the residual spot colour, the residual is divided by its 
; norm + lambda_d. Also, when the last OMP coefficients are computed for a pixel, they are computed on the total spot 
; colour divided by its norm + lambda_d.
lambda_d = 0.4

; If `False`, gene coefficients are found through omp with normal least squares fitting.
; If `True`, gene coefficients are found through omp with weighted least squares fitting
; with rounds/channels which already containing genes contributing less.
weight_coef_fit = False

; The maximum number of genes that can be assigned to each pixel i.e. number of iterations of omp.
max_genes = 10

; Pixels only have coefficient found for a gene if that gene has absolute `dot_product_score` greater than this.
; I.e. this is a stopping criterion for the OMP.
dp_thresh = 0.225

; When computing the dot product score, $\Delta_{sig}$ between spot $s$ and gene $g$ on iteration $i$ of *OMP*,
; rounds/channels with genes already fit to them, contribute less. The larger $\alpha$, the lower the contribution.
;
; Set $\alpha = 0$ to use the normal dot-product with no weighting.
alpha = 120

; Constant used in weighting factor when computing dot product score, $\Delta_{sig}$ between spot $s$ and gene $g$ on
; iteration $i$ of *OMP*.
beta = 1

; The number of pixels that coefficients are computed for at once.
subset_pixels = 540_000

; If set to true, pytorch OMP will always run on the CPU and never use a GPU, even if available.
force_cpu = false

; A maxima is not considered an OMP spot if there is another, larger maxima within this many pixels away in the x or y 
; direction of the same gene.
radius_xy = 3

; A maxima is not considered an OMP spot if there is another, larger maxima within this many pixels away in the z 
; direction of the same gene.
radius_z = 2

; spot_shape specifies the neighbourhood about each spot in which we count coefficients which contribute to score.
spot_shape = 9, 9, 5

; If the number of isolated spots goes above this value, then no more spots are used to compute the OMP spot/mean spot.
spot_shape_max_spots_considered = 100_000

; Spots are isolated if nearest neighbour is further away than this in y/x directions. Only isolated spots are used to 
; find `spot_shape`. The spots are found on each gene coefficient image.
shape_isolation_distance_yx = 10

; Spots are isolated if nearest neighbour is further away than this in the z direction. Only isolated spots are used to 
; find the OMP spot and mean spot.
; If left empty, the value is set to `ceil(shape_isolation_distance_yx * pixel_size_yx / pixel_size_z)`
shape_isolation_distance_z = 

; Spots are used to compute the OMP spot shape when they have a coefficient local maxima greater than this value.
shape_coefficient_threshold = 0.8

; If the mean absolute coefficient sign is less than this in a region near a spot,
; the expected coefficient in `spot` is set to 0.
; The maximum mean coefficient sign is 1, so must be less than this.
shape_sign_thresh = 0.1

; Pixels are computed on during OMP if they have a "max intensity" above this percentile value of all "max intensities"
; in the considered subset. The "max intensity" of a pixel is the median of the maximum absolute value across all 
; sequencing channels. For example, if pixel_max_percentile was 75, then 25% of all pixels on each subset will have 
; their OMP coefficients computed, the rest will remain zeros.
pixel_max_percentile = 0

; Any OMP spot scores below this threshold are not saved. Used to cut out false gene reads.
score_threshold = 0.1


[thresholds]
; The *thresholds* section contains the thresholds used to determine which spots pass a quality thresholding process
; such that we consider their gene assignments legitimate.


; Final accepted reference and OMP spots both require `intensity > thresholds[intensity]`.
; If not given, will be set to same value as `nb.call_spots.gene_efficiency_intensity_thresh`.
; intensity for a really intense spot is about 1 so `intensity_thresh` should be less than this.
intensity =

; Final accepted spots are those which pass quality_threshold which is
; `nb.ref_spots.scores > thresholds[score_ref]` and `nb.ref_spots.intensity > intensity_thresh`.
; quality_threshold requires score computed with *coppafish/call_spots/dot_prodduct/dot_product_score* to exceed this.
; Max score is 1 so must be below this.
score_ref = 0.25

; Final accepted OMP spots are those which pass quality_threshold which is:
; `score > thresholds[score_omp]` and `intensity > thresholds[intensity]`. `score` is given by:
; `score = (score_omp_multiplier * n_neighbours_pos + n_neighbours_neg) /
;   (score_omp_multiplier * n_neighbours_pos_max + n_neighbours_neg_max)`
; Max score is 1 so `score_thresh` should be less than this.
;
; 0.15 if more concerned for missed spots than false positives.
score_omp = 0.263

score_prob = 0.7

; Final accepted OMP spots are those which pass quality_threshold which is:
; `score > thresholds[score_omp]` and `intensity > thresholds[intensity]`. `score` is given by:
; `score = (score_omp_multiplier * n_neighbours_pos + n_neighbours_neg) /
;   (score_omp_multiplier * n_neighbours_pos_max + n_neighbours_neg_max)`
;
; 0.45 if more concerned for missed spots than false positives.
score_omp_multiplier = 0.95


[reg_to_anchor_info]
; Information relevant to the separate round registration


; Positions of bottom left corner of squares that we are comparing
full_anchor_y0 = 0
full_anchor_x0 = 0
partial_anchor_y0 = 0
partial_anchor_x0 = 0

; Side length of squares that we are comparing
side_length =
